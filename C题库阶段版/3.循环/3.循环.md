### 涉及算法

#### 平面上的n个点中找出横坐标最小的点

```c
printf("Please input n:");
scanf("%d",&n);

printf("x y\n");
scanf("%d %d",&x,&y);
minx=x;
miny=y;
for(i=1;i<=n-1;i++){  //已经输入一个，还剩n-1个 即1~n-1共n-1个 
    scanf("%d %d",&x,&y);
    if(minx>x){  //若输入x比当前minx更小，则赋值
        minx=x;
        miny=y;
    }
    else if(minx==x&&miny>y){ //若输入x与minx相等，且y比当前miny小，则赋值
        miny=y;
        minx=x;
    }
}
printf("\n%d %d",minx,miny);
```



#### 循环输出图案

##### 基本方法

1. 观察图形特征，判断确定是在矩阵的i，j满足何种条件下在该处区别输出
2. 尽量以熟悉的 **1** 开始进行行列的计数

##### 输出图案类题型不同换行之区别：

| 输出函数     | 输出结果                                                     |
| ------------ | ------------------------------------------------------------ |
| printf("\n") | 输出一个换行                                                 |
| putchar(10)  | 输出ASCII码为10的字符，该字符即是一个换行                    |
| puts("\n")   | puts()意思是输出内容并换行，'\n'本身就是换行，然后puts再换一行，就成两行了，不宜使用 |

##### X图案

```c
for(i=1;i<=2*n-1;i++){
    for(j=1;j<=2*n-1;j++){
        //输出字符位置的特征就是 i==j||i+j==2*n 
        if(i==j||i+j==2*n){
            printf("%c",'@');
        }
        else{
            printf("%c",' ');
        }
    }
    putchar(10);	
}
```



##### 镂空三角形

```c
for(i=1;i<n;i++){
    for(j=1;j<=(2*n)-1;j++){
        //镂空等腰三角形除了底边外，特征是在其中线两侧一定距离处输出字符 ，其行列之间关系为 j==n-(i-1)||j==n+(i-1) 
        if(j==n-(i-1)||j==n+(i-1)){  
            printf("%c",ch);
        }
        else{
            printf(" ");
        }
    }
    printf("\n");
}
//输出底边 
for(j=1;j<=2*n-1;j++){
    printf("%c",ch);
} 
```

##### 实心菱形

**注意上下对称对设计行号的影响** 

```c
//上半菱形 
for(i=1;i<=n;i++){
    for(j=1;j<=2*n-1;j++){
        //实心菱形特征是在其中线两侧一定范围的距离内输出字符 ，其行列之间关系为 j>=n-(i-1)&&j<=n+(i-1) 
        if(j>=n-(i-1)&&j<=n+(i-1)){
            printf("#");
        }
        else{
            printf(" ");
        }
    }
    putchar(10);
}
//下半菱形
//从i=n-1开始计数并累减至i=1即一开始的初始行值，根据对称性，j的取值特征不作变化
/*也即行号和列号标记(以n=4为例)为
		1 2 3 4 5 6 7
	1	      # 
	2	  	# # #
	3	  # # # # #
	4	# # # # # # #
	3	  # # # # #
	2	  	# # #
	1	      # 
	*/
for(i=n-1;i>=1;i--){
    for(j=1;j<=2*n-1;j++){
        if(j>=n-(i-1)&&j<=n+(i-1)){
            printf("#");
        }
        else{
            printf(" ");
        }
    }
    putchar(10);
}
```

##### 空心菱形/周边字母

**注意上下对称对设计行号的影响** 

```c
 //上半菱形 
for(i=1;i<=n;i++){
    for(j=1;j<=2*n-1;j++){
        //空心菱形特征是在其中线两侧一定距离处输出字符 ，其行列之间关系为 j==n-(i-1)||j==n+(i-1) ，同等腰三角
        if(j==n-(i-1)||j==n+(i-1)){
            printf("%c",ch+i-1);  //由于行号从1开始计数，故ch的累加需要对i的值-1 
        }
        else{
            printf(" ");
        }
    }
    putchar(10);
}
//下半菱形
//从i=n-1开始计数并累减至i=1即一开始的初始行值，根据对称性，j的取值特征不作变化
/*也即行号和列号标记(以n=4为例)为
		1 2 3 4 5 6 7
	1	      # 
	2	  	#   #
	3	  #       #
	4	#           #
	3	  #       #
	2	  	#   #
	1	      # 
	*/
for(i=n-1;i>=1;i--){
    for(j=1;j<=2*n-1;j++){
        if(j==n-(i-1)||j==n+(i-1)){
            printf("%c",ch+i-1);  //由于行号从1开始计数，故ch的累加需要对i的值-1 
        }
        else{
            printf(" ");
        }
    }
    putchar(10);
}
```

##### K形图案

**注意上下对称对设计行号的影响** 

```c
//上半K 
for(i=1;i<=n;i++){
    for(j=1;j<=n;j++){
        //K形的特征是每列第1行 行列数相加等于n+1时输出字符 即j==1||j+i==n+1
        if(j==1||j+i==n+1){
            printf("$");
        }
        else{
            printf(" ");
        }
    }
    putchar(10);
}
//下半K 
//从i=n-1开始计数并累减至i=1即一开始的初始行值，根据对称性，j的取值特征不作变化
/*也即行号和列号标记(以n=4为例)为
		1 2 3 4 5 6 7
	1	#     # 
	2	# 	#    
	3	# #        
	4	#            
	3	# #        
	2	# 	#    
	1	#     # 
	*/
for(i=n-1;i>=1;i--){
    for(j=1;j<=n;j++){
        if(j==1||j+i==n+1){
            printf("$");
        }
        else{
            printf(" ");
        }
    }
    putchar(10);
}
```

#### S=1/1！+1/2！+1/3！+…+1/N！只需一轮循环，循环内先累乘后累加

```c
for(i=1;i<=N;i++){
    factor*=i;
    sum+=1/(double)factor;
}
printf("S=1/1!+1/2!+...+1/%d!=%.16f\n",N,sum);
```



### 注意细节

#### printf()的对齐方式

```c
printf("%-3d",a); //表示输出 输出占3个宽度，且左对齐
printf("%d",a);  //对于整数和小数，默认右对齐，不足的宽度以空格补齐
```

