### 涉及函数

#### malloc()动态分配内存

| 属性     | 说明                                                         |
| :------- | ------------------------------------------------------------ |
| 头文件   | <stdlib.h>                                                   |
| 功能     | malloc() 函数用来动态地分配内存空间                          |
| 原型     | void* malloc (size_t size);                                  |
| 参数说明 | size 为需要分配的内存空间的大小，以字节（Byte）计。          |
| 函数说明 | malloc() 在堆区分配一块指定大小的内存空间，用来存放数据。<br/>这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。<br/>如果希望在分配内存的同时进行初始化，请使用 calloc() 函数。 |
| 返回值   | 分配成功返回指向该内存的地址，失败则返回 NULL。              |
| 注意事项 | 1. 由于申请内存空间时可能有也可能没有，所以需要自行判断是否申请成功，再进行后续操作。<br/>如果 size 的值为 0，那么返回值会因标准库实现的不同而不同，可能是 NULL，也可能不是，但返回的指针不应该再次被引用。<br/>2.函数的返回值类型是 void *，void 并不是说没有返回值或者返回空指针，而是返回的指针类型未知。<br/>	所以在使用 malloc() 时通常需要进行强制类型转换，将 void 指针转换成我们希望的类型 |
| 示例     | 题目z04中定义了int *a指针但是并未赋给指针初值，是一个野指针，于是使用malloc()动态分配内存给a赋初值<br/>     a = (int \*)malloc(5\*sizeof(int)); |
| free(p)  | 在 C 语言中，程序中 malloc 等内存分配函数的使用次数一定要和 free 相等，并一一配对使用。 |

#### 一维数组名作函数参数的问题

知道**1.数组的首地址，2.数组的长度——就可以唯一地确定一个一维数组。**因为数组是连续存放的，只要知道数组的首地址和数组的长度就能找到这个数组中所有的元素。

因此，要想通过实参和形参将一个数组从主调函数传到被调函数，那么只需要传递这两个信息即可。对于一维数组来说，其数组名就表示一维数组的首地址。

所以**只需要传递数组名和数组长度这两个参数就可以将数组从主调函数传入被调函数中。**
当**数组名作为函数的实参时，形参列表中也应定义相应的数组（或用指针变量）**，且定义数组的类型必须与实参数组的类型一致，如果不一致就会出错。

但**形参中定义的数组无须指定数组的长度，而是再定义一个参数用于传递数组的长度。(视情况如字符数组形参定义可以不传长度)**所以在传递实参的时候，数组名和数组长度也只能用两个参数分开传递，而不能写在一起。因为即使写在一起，系统在编译时也只是检查数组名，并不会检查数组长度。所以数组长度要额外定义一个变量进行传递。

综上所述，当将数组从一个函数传到另一个函数中时，并不是将数组中所有的元素一个一个传过来（那样效率就太低了）。
而是将能够唯一确定一个数组的信息传过来，即数组名（数组首地址）和数组长度。此时主调函数和被调函数操作的就是同一个数组。

```c
void copy_string(char from[], char to[]) //相当于char *from,char *to 
   
//调用时
    char a[31];
	char b[31];
	printf("Please input a string a is:");
	gets(a);
	printf("Please input a string b is:");
	gets(b);

	printf("Output:\n");
	printf("string a=%s\nstring b=%s\n",a,b);  
	printf("copy string a to string b:");

	copy_string(a,b);  //调用时只传字符数组名-其是一个指针常量
```



### 涉及算法

#### 指针遍历数组的又一种方法(不使用*(p+i)):

```c
for(i=0,p=a;i<5;p++,i++)
	{
		printf("%d ",*p);
	}
```

```c
for (i=0;i<5;i++,p++){
    scanf("%d", p);
}
```

#### 指针的复用

```c
main(){   
	int *PArray = NULL;
    int Total = 0,i = 0;
    printf("输入数组中元素的个数:");
    scanf("%d",&Total);

    PArray=(int *)malloc(Total*sizeof(int));//动态分配内存对指针初始化 

    printf("输入数组中元素:");
    for(i=0;i<Total;i++){
        scanf("%d",PArray + i);//指针首次使用：使用 PArray指针进行数组输入 
    } 
    PArray=Calc(PArray,Total);//指针第二次使用：先作为数组首地址参数传入函数，再作为返回值的地址返回求和的值，因为函数内部申请的变量会在函数执行结束后释放掉
    printf("数组的元素和是:%d",*PArray);
}


int *Calc(int *PA,int Num){
        int i,sum=0;
        for(i=0;i<Num;i++){
            sum+=(*(PA+i));
        }
        *PA=sum;
        return PA;
    }
```

#### 数组原地反转的2种算法

##### 使用while循环反转

```c
void inv(int *x,int n){     //形参定义为数组首地址和数组长度              //形参x是指针变量       
	int i,temp;
   
    i=0; 					//记得这个 i 计数器值的初始化
	while(i<=n/2-1){
		temp=*(x+i);
		*(x+i)=*(x+n-1-i);
		*(x+n-1-i)=temp;
		i++;  				//记得加这个i++
	}
}
```

##### 使用for循环反转

```c
void inv(int *x,int n){     //形参定义为数组首地址和数组长度              //形参x是指针变量       
	int i, tmp;
	for (i=0;i<=n/2-1;i++){  //计数器i初始化和i++都已在for后面语句中声明
		tmp = *(x+i);
		*(x+i) = *(x+n-1-i);
		*(x+n-1-i) = tmp;
	}
}
```

### 注意细节

#### 指针变量的正确使用方法

**<font color=red>C语言中的正确做法是先让指针变量指向一个确定的存储单元后，再通过该指针变量应用它所指向的存储单元</font>**

纵览本章的编程题，从没有直接对只是定义过的指针变量进行操作的，尤其在使用字符数组时尤其注意

```c
char *str;
gets(str);  //不合法的操作，编译可能通过但是执行报错
```

这是不合法的：**指针如果没有被赋值，它的值是不确定的，即它指向一个不确定的单元，使用这样的指针，可能会出现难以预料的结果，甚至导致系统错误。**

